/*
 * BSD 2-Clause License:
 * Copyright (c) 2018 - 2019
 * Software Technology Group
 * Department of Computer Science
 * Technische UniversitÃ¤t Darmstadt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package Actions.resolve;

import JavaByteCodeLanguage.autoGenerated.psi.JavaByteCodeJType;
import com.intellij.notification.NotificationDisplayType;
import com.intellij.notification.NotificationGroup;
import com.intellij.notification.Notifications;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.CommonDataKeys;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiFile;
import com.intellij.psi.util.PsiTreeUtil;
import java.util.Objects;

import org.jetbrains.annotations.NotNull;
import taclanguage.autogenerated.psi.TACJType;

import static globalData.GlobalData.BYTECODE_EDITOR_ID;

class JumpToResolve extends AnAction {
  private final String editorName;
  private final String ending;
  JumpToResolve(String editorName,String ending) {
    this.editorName = editorName;
    this.ending = ending;

  }
  public void update(@NotNull AnActionEvent e) {
    final VirtualFile virtualFile = e.getData(CommonDataKeys.VIRTUAL_FILE);
    Editor editor = e.getData(CommonDataKeys.EDITOR);
    PsiFile psiFile = e.getData(CommonDataKeys.PSI_FILE);
    final String extension = virtualFile != null ? virtualFile.getExtension() : "";
    PsiElement element =
            Objects.requireNonNull(psiFile)
                    .findElementAt(Objects.requireNonNull(editor).getCaretModel().getOffset());
    element = PsiTreeUtil.getParentOfType(element, JavaByteCodeJType.class);
    e.getPresentation().setEnabledAndVisible(element != null && ending.equals(extension));
  }
  @Override
  public void actionPerformed(AnActionEvent e) {
    Project project = e.getProject();
    Editor editor = e.getData(CommonDataKeys.EDITOR);
    PsiFile psiFile = e.getData(CommonDataKeys.PSI_FILE);
    if (editor == null || psiFile == null || project == null) {
      return;
    }
    PsiElement elementAt = psiFile.findElementAt(editor.getCaretModel().getOffset());
    PsiElement fullyQualifiedClass =
            BYTECODE_EDITOR_ID.equals(editorName)
            ? PsiTreeUtil.getParentOfType(elementAt, JavaByteCodeJType.class)
            : PsiTreeUtil.getParentOfType(elementAt, TACJType.class);
    if (fullyQualifiedClass != null) {
      // e.g. java.lang.String -> resolve = String
      PsiElement resolve =
          fullyQualifiedClass.getReferences()[fullyQualifiedClass.getReferences().length - 1]
              .resolve();
      PsiFile resolvePsiFile = Objects.requireNonNull(resolve).getContainingFile();
      VirtualFile resolvedVirtualFile = resolvePsiFile.getVirtualFile();
      FileEditorManager.getInstance(project).openFile(resolvedVirtualFile, true);
      FileEditorManager.getInstance(project).setSelectedEditor(resolvedVirtualFile, BYTECODE_EDITOR_ID);
      return;
    }
    Notifications.Bus.notify(
        new NotificationGroup("OpalPlugin", NotificationDisplayType.BALLOON, false)
            .createNotification()
            .setContent("can't find navigation path"));
  }
}
