// This is a generated file. Not intended for manual editing.
package JavaByteCodeLanguage.autoGenerated.parser;

import com.intellij.lang.PsiBuilder;
import com.intellij.lang.PsiBuilder.Marker;
import static JavaByteCodeLanguage.autoGenerated.psi.JavaByteCodeTypes.*;
import static JavaByteCodeLanguage.autoGenerated.parser.JavaByteCodeParserUtil.*;
import com.intellij.psi.tree.IElementType;
import com.intellij.lang.ASTNode;
import com.intellij.psi.tree.TokenSet;
import com.intellij.lang.PsiParser;
import com.intellij.lang.LightPsiParser;

@SuppressWarnings({"SimplifiableIfStatement", "UnusedAssignment"})
public class JavaByteCodeParser implements PsiParser, LightPsiParser {

  public ASTNode parse(IElementType t, PsiBuilder b) {
    parseLight(t, b);
    return b.getTreeBuilt();
  }

  public void parseLight(IElementType t, PsiBuilder b) {
    boolean r;
    b = adapt_builder_(t, b, this, null);
    Marker m = enter_section_(b, 0, _COLLAPSE_, null);
    if (t == ANNOTATION) {
      r = Annotation(b, 0);
    }
    else if (t == ATTRIBUTES_AREA) {
      r = AttributesArea(b, 0);
    }
    else if (t == CLASS_HEAD) {
      r = ClassHead(b, 0);
    }
    else if (t == DEF_METHOD_NAME) {
      r = DefMethodName(b, 0);
    }
    else if (t == EXCEPTION_TABLE_BODY) {
      r = ExceptionTableBody(b, 0);
    }
    else if (t == EXCEPTION_TABLE_DECLARATION) {
      r = ExceptionTableDeclaration(b, 0);
    }
    else if (t == FIELD_AREA) {
      r = FieldArea(b, 0);
    }
    else if (t == FIELDS_DECLARATION) {
      r = FieldsDeclaration(b, 0);
    }
    else if (t == INNER_TABLE) {
      r = InnerTable(b, 0);
    }
    else if (t == INSTR) {
      r = Instr(b, 0);
    }
    else if (t == INSTRUCTION_BODY) {
      r = InstructionBody(b, 0);
    }
    else if (t == J_TYPE) {
      r = JType(b, 0);
    }
    else if (t == JAVA_OP) {
      r = JavaOP(b, 0);
    }
    else if (t == LAMBDA_TYPE) {
      r = LambdaType(b, 0);
    }
    else if (t == LINE_NUMBER) {
      r = LineNumber(b, 0);
    }
    else if (t == LOC_VAR_TABLE_DECLARATION) {
      r = LocVarTableDeclaration(b, 0);
    }
    else if (t == LOC_VAR_TYPE_TABLE_BODY) {
      r = LocVarTypeTableBody(b, 0);
    }
    else if (t == LOC_VAR_TYPE_TABLE_DECLARATION) {
      r = LocVarTypeTableDeclaration(b, 0);
    }
    else if (t == METHOD_AREA) {
      r = MethodArea(b, 0);
    }
    else if (t == METHOD_DECLARATION) {
      r = MethodDeclaration(b, 0);
    }
    else if (t == METHOD_HEAD) {
      r = MethodHead(b, 0);
    }
    else if (t == METHOD_NAME) {
      r = MethodName(b, 0);
    }
    else if (t == MODIFIER_V) {
      r = ModifierV(b, 0);
    }
    else if (t == PC_NUMBER) {
      r = PcNumber(b, 0);
    }
    else if (t == STACK_MAP_TABLE_DECLARATION) {
      r = StackMapTableDeclaration(b, 0);
    }
    else if (t == TABLE_AREA) {
      r = TableArea(b, 0);
    }
    else if (t == TYPE) {
      r = Type(b, 0);
    }
    else if (t == LAMBDA_PARAMS) {
      r = lambdaParams(b, 0);
    }
    else if (t == PARAMS) {
      r = params(b, 0);
    }
    else {
      r = parse_root_(t, b, 0);
    }
    exit_section_(b, 0, m, t, r, true, TRUE_CONDITION);
  }

  protected boolean parse_root_(IElementType t, PsiBuilder b, int l) {
    return jbcFile(b, l + 1);
  }

  /* ********************************************************** */
  // AT JType
  public static boolean Annotation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation")) return false;
    if (!nextTokenIs(b, AT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, AT);
    r = r && JType(b, l + 1);
    exit_section_(b, m, ANNOTATION, r);
    return r;
  }

  /* ********************************************************** */
  // ATTRIBUTES LBRACKET InnerTable? RBRACKET
  public static boolean AttributesArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "AttributesArea")) return false;
    if (!nextTokenIs(b, ATTRIBUTES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ATTRIBUTES, LBRACKET);
    r = r && AttributesArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, ATTRIBUTES_AREA, r);
    return r;
  }

  // InnerTable?
  private static boolean AttributesArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "AttributesArea_2")) return false;
    InnerTable(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ModifierV? (AT?) JAVATYPEHEAD JType (EXTENDS JType)? (IMPLEMENTS (JType(COMMA)?)+)?
  public static boolean ClassHead(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CLASS_HEAD, "<class head>");
    r = ClassHead_0(b, l + 1);
    r = r && ClassHead_1(b, l + 1);
    r = r && consumeToken(b, JAVATYPEHEAD);
    r = r && JType(b, l + 1);
    r = r && ClassHead_4(b, l + 1);
    r = r && ClassHead_5(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean ClassHead_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  // AT?
  private static boolean ClassHead_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_1")) return false;
    consumeToken(b, AT);
    return true;
  }

  // (EXTENDS JType)?
  private static boolean ClassHead_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_4")) return false;
    ClassHead_4_0(b, l + 1);
    return true;
  }

  // EXTENDS JType
  private static boolean ClassHead_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, EXTENDS);
    r = r && JType(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (IMPLEMENTS (JType(COMMA)?)+)?
  private static boolean ClassHead_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5")) return false;
    ClassHead_5_0(b, l + 1);
    return true;
  }

  // IMPLEMENTS (JType(COMMA)?)+
  private static boolean ClassHead_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IMPLEMENTS);
    r = r && ClassHead_5_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (JType(COMMA)?)+
  private static boolean ClassHead_5_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = ClassHead_5_0_1_0(b, l + 1);
    while (r) {
      int c = current_position_(b);
      if (!ClassHead_5_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "ClassHead_5_0_1", c)) break;
    }
    exit_section_(b, m, null, r);
    return r;
  }

  // JType(COMMA)?
  private static boolean ClassHead_5_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && ClassHead_5_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (COMMA)?
  private static boolean ClassHead_5_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // STRINGVAR
  public static boolean DefMethodName(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "DefMethodName")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STRINGVAR);
    exit_section_(b, m, DEF_METHOD_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // "try" LBRACKET NUMBER COMMA NUMBER RBRACKET "catch" NUMBER (Type|STRINGVAR)
  public static boolean ExceptionTableBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ExceptionTableBody")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EXCEPTION_TABLE_BODY, "<exception table body>");
    r = consumeToken(b, "try");
    r = r && consumeTokens(b, 0, LBRACKET, NUMBER, COMMA, NUMBER, RBRACKET);
    r = r && consumeToken(b, "catch");
    r = r && consumeToken(b, NUMBER);
    r = r && ExceptionTableBody_8(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // Type|STRINGVAR
  private static boolean ExceptionTableBody_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ExceptionTableBody_8")) return false;
    boolean r;
    r = Type(b, l + 1);
    if (!r) r = consumeToken(b, STRINGVAR);
    return r;
  }

  /* ********************************************************** */
  // TABLENAME LBRACKET ExceptionTableBody* RBRACKET
  public static boolean ExceptionTableDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ExceptionTableDeclaration")) return false;
    if (!nextTokenIs(b, TABLENAME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLENAME, LBRACKET);
    r = r && ExceptionTableDeclaration_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, EXCEPTION_TABLE_DECLARATION, r);
    return r;
  }

  // ExceptionTableBody*
  private static boolean ExceptionTableDeclaration_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ExceptionTableDeclaration_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!ExceptionTableBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "ExceptionTableDeclaration_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // FIELDS LBRACKET FieldsDeclaration* RBRACKET
  public static boolean FieldArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldArea")) return false;
    if (!nextTokenIs(b, FIELDS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FIELDS, LBRACKET);
    r = r && FieldArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, FIELD_AREA, r);
    return r;
  }

  // FieldsDeclaration*
  private static boolean FieldArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldArea_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!FieldsDeclaration(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "FieldArea_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // ModifierV? Type DefMethodName
  public static boolean FieldsDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldsDeclaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FIELDS_DECLARATION, "<fields declaration>");
    r = FieldsDeclaration_0(b, l + 1);
    r = r && Type(b, l + 1);
    r = r && DefMethodName(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean FieldsDeclaration_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldsDeclaration_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // STRINGVAR LBRACKET
  //                     (Type LBRACKET ModifierV JAVATYPEHEAD? STRINGVAR RBRACKET)*
  //                RBRACKET
  public static boolean InnerTable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, LBRACKET);
    r = r && InnerTable_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, INNER_TABLE, r);
    return r;
  }

  // (Type LBRACKET ModifierV JAVATYPEHEAD? STRINGVAR RBRACKET)*
  private static boolean InnerTable_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!InnerTable_2_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "InnerTable_2", c)) break;
    }
    return true;
  }

  // Type LBRACKET ModifierV JAVATYPEHEAD? STRINGVAR RBRACKET
  private static boolean InnerTable_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Type(b, l + 1);
    r = r && consumeToken(b, LBRACKET);
    r = r && ModifierV(b, l + 1);
    r = r && InnerTable_2_0_3(b, l + 1);
    r = r && consumeTokens(b, 0, STRINGVAR, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // JAVATYPEHEAD?
  private static boolean InnerTable_2_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2_0_3")) return false;
    consumeToken(b, JAVATYPEHEAD);
    return true;
  }

  /* ********************************************************** */
  // MNEMONIC (LBRACKET JType COLON Type RBRACKET                       // put someFQN : someFQN
  //                           | LBRACKET NUMBER RBRACKET
  //                           | LBRACKET STRING RBRACKET
  //                           | LBRACKET ((JavaOP|NUMBER|STRING)COMMA?)* RBRACKET   // LDC("someString") or ALOAD(5) or ...
  //                           // TABLESWITCH
  //                           | LBRACKET NUMBER TO NUMBER SEMICOLON
  //                                      (NUMBER SWITCH NUMBER COMMA?)* SEMICOLON?
  //                                      MODIFIER SWITCH NUMBER
  //                             RBRACKET
  //                             // LOOKUPSWITCH(default:34[(case:-127,31)(case:128,26)])
  //                           | LBRACKET MODIFIER COLON NUMBER
  //                                 LBRACKET
  //                                   (LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET)*
  //                                 RBRACKET
  //                             RBRACKET
  //                           | JavaOP)?
  public static boolean Instr(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr")) return false;
    if (!nextTokenIs(b, MNEMONIC)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, MNEMONIC);
    r = r && Instr_1(b, l + 1);
    exit_section_(b, m, INSTR, r);
    return r;
  }

  // (LBRACKET JType COLON Type RBRACKET                       // put someFQN : someFQN
  //                           | LBRACKET NUMBER RBRACKET
  //                           | LBRACKET STRING RBRACKET
  //                           | LBRACKET ((JavaOP|NUMBER|STRING)COMMA?)* RBRACKET   // LDC("someString") or ALOAD(5) or ...
  //                           // TABLESWITCH
  //                           | LBRACKET NUMBER TO NUMBER SEMICOLON
  //                                      (NUMBER SWITCH NUMBER COMMA?)* SEMICOLON?
  //                                      MODIFIER SWITCH NUMBER
  //                             RBRACKET
  //                             // LOOKUPSWITCH(default:34[(case:-127,31)(case:128,26)])
  //                           | LBRACKET MODIFIER COLON NUMBER
  //                                 LBRACKET
  //                                   (LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET)*
  //                                 RBRACKET
  //                             RBRACKET
  //                           | JavaOP)?
  private static boolean Instr_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1")) return false;
    Instr_1_0(b, l + 1);
    return true;
  }

  // LBRACKET JType COLON Type RBRACKET                       // put someFQN : someFQN
  //                           | LBRACKET NUMBER RBRACKET
  //                           | LBRACKET STRING RBRACKET
  //                           | LBRACKET ((JavaOP|NUMBER|STRING)COMMA?)* RBRACKET   // LDC("someString") or ALOAD(5) or ...
  //                           // TABLESWITCH
  //                           | LBRACKET NUMBER TO NUMBER SEMICOLON
  //                                      (NUMBER SWITCH NUMBER COMMA?)* SEMICOLON?
  //                                      MODIFIER SWITCH NUMBER
  //                             RBRACKET
  //                             // LOOKUPSWITCH(default:34[(case:-127,31)(case:128,26)])
  //                           | LBRACKET MODIFIER COLON NUMBER
  //                                 LBRACKET
  //                                   (LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET)*
  //                                 RBRACKET
  //                             RBRACKET
  //                           | JavaOP
  private static boolean Instr_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Instr_1_0_0(b, l + 1);
    if (!r) r = parseTokens(b, 0, LBRACKET, NUMBER, RBRACKET);
    if (!r) r = parseTokens(b, 0, LBRACKET, STRING, RBRACKET);
    if (!r) r = Instr_1_0_3(b, l + 1);
    if (!r) r = Instr_1_0_4(b, l + 1);
    if (!r) r = Instr_1_0_5(b, l + 1);
    if (!r) r = JavaOP(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // LBRACKET JType COLON Type RBRACKET
  private static boolean Instr_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && JType(b, l + 1);
    r = r && consumeToken(b, COLON);
    r = r && Type(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // LBRACKET ((JavaOP|NUMBER|STRING)COMMA?)* RBRACKET
  private static boolean Instr_1_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && Instr_1_0_3_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // ((JavaOP|NUMBER|STRING)COMMA?)*
  private static boolean Instr_1_0_3_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_3_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Instr_1_0_3_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Instr_1_0_3_1", c)) break;
    }
    return true;
  }

  // (JavaOP|NUMBER|STRING)COMMA?
  private static boolean Instr_1_0_3_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_3_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Instr_1_0_3_1_0_0(b, l + 1);
    r = r && Instr_1_0_3_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // JavaOP|NUMBER|STRING
  private static boolean Instr_1_0_3_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_3_1_0_0")) return false;
    boolean r;
    r = JavaOP(b, l + 1);
    if (!r) r = consumeToken(b, NUMBER);
    if (!r) r = consumeToken(b, STRING);
    return r;
  }

  // COMMA?
  private static boolean Instr_1_0_3_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_3_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // LBRACKET NUMBER TO NUMBER SEMICOLON
  //                                      (NUMBER SWITCH NUMBER COMMA?)* SEMICOLON?
  //                                      MODIFIER SWITCH NUMBER
  //                             RBRACKET
  private static boolean Instr_1_0_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LBRACKET, NUMBER, TO, NUMBER, SEMICOLON);
    r = r && Instr_1_0_4_5(b, l + 1);
    r = r && Instr_1_0_4_6(b, l + 1);
    r = r && consumeTokens(b, 0, MODIFIER, SWITCH, NUMBER, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // (NUMBER SWITCH NUMBER COMMA?)*
  private static boolean Instr_1_0_4_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_4_5")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Instr_1_0_4_5_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Instr_1_0_4_5", c)) break;
    }
    return true;
  }

  // NUMBER SWITCH NUMBER COMMA?
  private static boolean Instr_1_0_4_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_4_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, NUMBER, SWITCH, NUMBER);
    r = r && Instr_1_0_4_5_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Instr_1_0_4_5_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_4_5_0_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // SEMICOLON?
  private static boolean Instr_1_0_4_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_4_6")) return false;
    consumeToken(b, SEMICOLON);
    return true;
  }

  // LBRACKET MODIFIER COLON NUMBER
  //                                 LBRACKET
  //                                   (LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET)*
  //                                 RBRACKET
  //                             RBRACKET
  private static boolean Instr_1_0_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_5")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LBRACKET, MODIFIER, COLON, NUMBER, LBRACKET);
    r = r && Instr_1_0_5_5(b, l + 1);
    r = r && consumeTokens(b, 0, RBRACKET, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // (LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET)*
  private static boolean Instr_1_0_5_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_5_5")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Instr_1_0_5_5_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Instr_1_0_5_5", c)) break;
    }
    return true;
  }

  // LBRACKET CASE COLON NUMBER COMMA NUMBER RBRACKET
  private static boolean Instr_1_0_5_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_1_0_5_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, LBRACKET, CASE, COLON, NUMBER, COMMA, NUMBER, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // TAB* PcNumber LineNumber Instr
  public static boolean InstructionBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InstructionBody")) return false;
    if (!nextTokenIs(b, "<instruction body>", NUMBER, TAB)) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INSTRUCTION_BODY, "<instruction body>");
    r = InstructionBody_0(b, l + 1);
    r = r && PcNumber(b, l + 1);
    r = r && LineNumber(b, l + 1);
    r = r && Instr(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // TAB*
  private static boolean InstructionBody_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InstructionBody_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, TAB)) break;
      if (!empty_element_parsed_guard_(b, "InstructionBody_0", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // (STRINGVAR DOT)*(STRINGVAR | JAVATYPEHEAD | TABLENAME | MNEMONIC)
  public static boolean JType(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, J_TYPE, "<j type>");
    r = JType_0(b, l + 1);
    r = r && JType_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // (STRINGVAR DOT)*
  private static boolean JType_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!JType_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "JType_0", c)) break;
    }
    return true;
  }

  // STRINGVAR DOT
  private static boolean JType_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, DOT);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRINGVAR | JAVATYPEHEAD | TABLENAME | MNEMONIC
  private static boolean JType_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_1")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = consumeToken(b, JAVATYPEHEAD);
    if (!r) r = consumeToken(b, TABLENAME);
    if (!r) r = consumeToken(b, MNEMONIC);
    return r;
  }

  /* ********************************************************** */
  // "lvIndex=" NUMBER|((Type|STRINGVAR)(LBRACKET Type MethodName RBRACKET)?)+
  public static boolean JavaOP(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, JAVA_OP, "<java op>");
    r = parseTokens(b, 0, LVINDEX, NUMBER);
    if (!r) r = JavaOP_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ((Type|STRINGVAR)(LBRACKET Type MethodName RBRACKET)?)+
  private static boolean JavaOP_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JavaOP_1_0(b, l + 1);
    while (r) {
      int c = current_position_(b);
      if (!JavaOP_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "JavaOP_1", c)) break;
    }
    exit_section_(b, m, null, r);
    return r;
  }

  // (Type|STRINGVAR)(LBRACKET Type MethodName RBRACKET)?
  private static boolean JavaOP_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JavaOP_1_0_0(b, l + 1);
    r = r && JavaOP_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // Type|STRINGVAR
  private static boolean JavaOP_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP_1_0_0")) return false;
    boolean r;
    r = Type(b, l + 1);
    if (!r) r = consumeToken(b, STRINGVAR);
    return r;
  }

  // (LBRACKET Type MethodName RBRACKET)?
  private static boolean JavaOP_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP_1_0_1")) return false;
    JavaOP_1_0_1_0(b, l + 1);
    return true;
  }

  // LBRACKET Type MethodName RBRACKET
  private static boolean JavaOP_1_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JavaOP_1_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && Type(b, l + 1);
    r = r && MethodName(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // (STRINGVAR DOT)*STRINGVAR lambdaParams STRINGVAR COLON* NUMBER STRINGVAR
  public static boolean LambdaType(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = LambdaType_0(b, l + 1);
    r = r && consumeToken(b, STRINGVAR);
    r = r && lambdaParams(b, l + 1);
    r = r && consumeToken(b, STRINGVAR);
    r = r && LambdaType_4(b, l + 1);
    r = r && consumeTokens(b, 0, NUMBER, STRINGVAR);
    exit_section_(b, m, LAMBDA_TYPE, r);
    return r;
  }

  // (STRINGVAR DOT)*
  private static boolean LambdaType_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LambdaType_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LambdaType_0", c)) break;
    }
    return true;
  }

  // STRINGVAR DOT
  private static boolean LambdaType_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, DOT);
    exit_section_(b, m, null, r);
    return r;
  }

  // COLON*
  private static boolean LambdaType_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_4")) return false;
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, COLON)) break;
      if (!empty_element_parsed_guard_(b, "LambdaType_4", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // NUMBER
  public static boolean LineNumber(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LineNumber")) return false;
    if (!nextTokenIs(b, NUMBER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    exit_section_(b, m, LINE_NUMBER, r);
    return r;
  }

  /* ********************************************************** */
  // "pc" EQ LBRACKET NUMBER TO NUMBER RBRACKET SLASH "lv" EQ NUMBER TO Type (this | STRINGVAR)
  static boolean LocVarTableBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTableBody")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "pc");
    r = r && consumeTokens(b, 0, EQ, LBRACKET, NUMBER, TO, NUMBER, RBRACKET, SLASH);
    r = r && consumeToken(b, "lv");
    r = r && consumeTokens(b, 0, EQ, NUMBER, TO);
    r = r && Type(b, l + 1);
    r = r && LocVarTableBody_13(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // this | STRINGVAR
  private static boolean LocVarTableBody_13(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTableBody_13")) return false;
    boolean r;
    r = consumeToken(b, THIS);
    if (!r) r = consumeToken(b, STRINGVAR);
    return r;
  }

  /* ********************************************************** */
  // TABLENAME LBRACKET LocVarTableBody* RBRACKET
  public static boolean LocVarTableDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTableDeclaration")) return false;
    if (!nextTokenIs(b, TABLENAME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLENAME, LBRACKET);
    r = r && LocVarTableDeclaration_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, LOC_VAR_TABLE_DECLARATION, r);
    return r;
  }

  // LocVarTableBody*
  private static boolean LocVarTableDeclaration_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTableDeclaration_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LocVarTableBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LocVarTableDeclaration_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // "pc" EQ LBRACKET NUMBER TO NUMBER RBRACKET SLASH "lv" EQ NUMBER TO STRINGVAR COLON
  //         ((STRINGVAR SLASH?)* SEMICOLON)*
  public static boolean LocVarTypeTableBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LOC_VAR_TYPE_TABLE_BODY, "<loc var type table body>");
    r = consumeToken(b, "pc");
    r = r && consumeTokens(b, 0, EQ, LBRACKET, NUMBER, TO, NUMBER, RBRACKET, SLASH);
    r = r && consumeToken(b, "lv");
    r = r && consumeTokens(b, 0, EQ, NUMBER, TO, STRINGVAR, COLON);
    r = r && LocVarTypeTableBody_14(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ((STRINGVAR SLASH?)* SEMICOLON)*
  private static boolean LocVarTypeTableBody_14(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody_14")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LocVarTypeTableBody_14_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LocVarTypeTableBody_14", c)) break;
    }
    return true;
  }

  // (STRINGVAR SLASH?)* SEMICOLON
  private static boolean LocVarTypeTableBody_14_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody_14_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = LocVarTypeTableBody_14_0_0(b, l + 1);
    r = r && consumeToken(b, SEMICOLON);
    exit_section_(b, m, null, r);
    return r;
  }

  // (STRINGVAR SLASH?)*
  private static boolean LocVarTypeTableBody_14_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody_14_0_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LocVarTypeTableBody_14_0_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LocVarTypeTableBody_14_0_0", c)) break;
    }
    return true;
  }

  // STRINGVAR SLASH?
  private static boolean LocVarTypeTableBody_14_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody_14_0_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STRINGVAR);
    r = r && LocVarTypeTableBody_14_0_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // SLASH?
  private static boolean LocVarTypeTableBody_14_0_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableBody_14_0_0_0_1")) return false;
    consumeToken(b, SLASH);
    return true;
  }

  /* ********************************************************** */
  // TABLENAME LBRACKET LocVarTypeTableBody* RBRACKET
  public static boolean LocVarTypeTableDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableDeclaration")) return false;
    if (!nextTokenIs(b, TABLENAME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLENAME, LBRACKET);
    r = r && LocVarTypeTableDeclaration_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, LOC_VAR_TYPE_TABLE_DECLARATION, r);
    return r;
  }

  // LocVarTypeTableBody*
  private static boolean LocVarTypeTableDeclaration_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LocVarTypeTableDeclaration_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LocVarTypeTableBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LocVarTypeTableDeclaration_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // METHODS LBRACKET MethodDeclaration* RBRACKET
  public static boolean MethodArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodArea")) return false;
    if (!nextTokenIs(b, METHODS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, METHODS, LBRACKET);
    r = r && MethodArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, METHOD_AREA, r);
    return r;
  }

  // MethodDeclaration*
  private static boolean MethodArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodArea_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!MethodDeclaration(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodArea_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // Annotation* MethodHead LBRACKET
  //         (INSTRUCTIONHEAD
  //          InstructionBody*
  //          TableArea?)*
  //         RBRACKET
  public static boolean MethodDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_DECLARATION, "<method declaration>");
    r = MethodDeclaration_0(b, l + 1);
    r = r && MethodHead(b, l + 1);
    r = r && consumeToken(b, LBRACKET);
    r = r && MethodDeclaration_3(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // Annotation*
  private static boolean MethodDeclaration_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodDeclaration_0", c)) break;
    }
    return true;
  }

  // (INSTRUCTIONHEAD
  //          InstructionBody*
  //          TableArea?)*
  private static boolean MethodDeclaration_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_3")) return false;
    while (true) {
      int c = current_position_(b);
      if (!MethodDeclaration_3_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodDeclaration_3", c)) break;
    }
    return true;
  }

  // INSTRUCTIONHEAD
  //          InstructionBody*
  //          TableArea?
  private static boolean MethodDeclaration_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, INSTRUCTIONHEAD);
    r = r && MethodDeclaration_3_0_1(b, l + 1);
    r = r && MethodDeclaration_3_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // InstructionBody*
  private static boolean MethodDeclaration_3_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_3_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!InstructionBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodDeclaration_3_0_1", c)) break;
    }
    return true;
  }

  // TableArea?
  private static boolean MethodDeclaration_3_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_3_0_2")) return false;
    TableArea(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // ModifierV? Type MethodName
  public static boolean MethodHead(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodHead")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_HEAD, "<method head>");
    r = MethodHead_0(b, l + 1);
    r = r && Type(b, l + 1);
    r = r && MethodName(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean MethodHead_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodHead_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DefMethodName params exceptionList*
  public static boolean MethodName(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodName")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = DefMethodName(b, l + 1);
    r = r && params(b, l + 1);
    r = r && MethodName_2(b, l + 1);
    exit_section_(b, m, METHOD_NAME, r);
    return r;
  }

  // exceptionList*
  private static boolean MethodName_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodName_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!exceptionList(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodName_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // MODIFIER*
  public static boolean ModifierV(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ModifierV")) return false;
    Marker m = enter_section_(b, l, _NONE_, MODIFIER_V, "<modifier v>");
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, MODIFIER)) break;
      if (!empty_element_parsed_guard_(b, "ModifierV", c)) break;
    }
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  /* ********************************************************** */
  // NUMBER
  public static boolean PcNumber(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "PcNumber")) return false;
    if (!nextTokenIs(b, NUMBER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    exit_section_(b, m, PC_NUMBER, r);
    return r;
  }

  /* ********************************************************** */
  // NUMBER Type NUMBER NUMBER
  //     [("Locals:"? (Type COMMA?)*)?
  //      SEMICOLON?
  //      ("Stack:"? ((((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*))?]
  static boolean StackMapTableBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody")) return false;
    if (!nextTokenIs(b, NUMBER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    r = r && Type(b, l + 1);
    r = r && consumeTokens(b, 0, NUMBER, NUMBER);
    r = r && StackMapTableBody_4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [("Locals:"? (Type COMMA?)*)?
  //      SEMICOLON?
  //      ("Stack:"? ((((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*))?]
  private static boolean StackMapTableBody_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4")) return false;
    StackMapTableBody_4_0(b, l + 1);
    return true;
  }

  // ("Locals:"? (Type COMMA?)*)?
  //      SEMICOLON?
  //      ("Stack:"? ((((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*))?
  private static boolean StackMapTableBody_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = StackMapTableBody_4_0_0(b, l + 1);
    r = r && StackMapTableBody_4_0_1(b, l + 1);
    r = r && StackMapTableBody_4_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ("Locals:"? (Type COMMA?)*)?
  private static boolean StackMapTableBody_4_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0")) return false;
    StackMapTableBody_4_0_0_0(b, l + 1);
    return true;
  }

  // "Locals:"? (Type COMMA?)*
  private static boolean StackMapTableBody_4_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = StackMapTableBody_4_0_0_0_0(b, l + 1);
    r = r && StackMapTableBody_4_0_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // "Locals:"?
  private static boolean StackMapTableBody_4_0_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0_0_0")) return false;
    consumeToken(b, "Locals:");
    return true;
  }

  // (Type COMMA?)*
  private static boolean StackMapTableBody_4_0_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!StackMapTableBody_4_0_0_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "StackMapTableBody_4_0_0_0_1", c)) break;
    }
    return true;
  }

  // Type COMMA?
  private static boolean StackMapTableBody_4_0_0_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Type(b, l + 1);
    r = r && StackMapTableBody_4_0_0_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean StackMapTableBody_4_0_0_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_0_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // SEMICOLON?
  private static boolean StackMapTableBody_4_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_1")) return false;
    consumeToken(b, SEMICOLON);
    return true;
  }

  // ("Stack:"? ((((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*))?
  private static boolean StackMapTableBody_4_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2")) return false;
    StackMapTableBody_4_0_2_0(b, l + 1);
    return true;
  }

  // "Stack:"? ((((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*)
  private static boolean StackMapTableBody_4_0_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = StackMapTableBody_4_0_2_0_0(b, l + 1);
    r = r && StackMapTableBody_4_0_2_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // "Stack:"?
  private static boolean StackMapTableBody_4_0_2_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0_0")) return false;
    consumeToken(b, "Stack:");
    return true;
  }

  // (((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?)*
  private static boolean StackMapTableBody_4_0_2_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!StackMapTableBody_4_0_2_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "StackMapTableBody_4_0_2_0_1", c)) break;
    }
    return true;
  }

  // ((STRINGVAR LBRACKET NUMBER RBRACKET|Type)) COMMA?
  private static boolean StackMapTableBody_4_0_2_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = StackMapTableBody_4_0_2_0_1_0_0(b, l + 1);
    r = r && StackMapTableBody_4_0_2_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRINGVAR LBRACKET NUMBER RBRACKET|Type
  private static boolean StackMapTableBody_4_0_2_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = parseTokens(b, 0, STRINGVAR, LBRACKET, NUMBER, RBRACKET);
    if (!r) r = Type(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean StackMapTableBody_4_0_2_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableBody_4_0_2_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // TABLENAME LBRACKET StackMapTableBody* RBRACKET
  public static boolean StackMapTableDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableDeclaration")) return false;
    if (!nextTokenIs(b, TABLENAME)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLENAME, LBRACKET);
    r = r && StackMapTableDeclaration_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, STACK_MAP_TABLE_DECLARATION, r);
    return r;
  }

  // StackMapTableBody*
  private static boolean StackMapTableDeclaration_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "StackMapTableDeclaration_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!StackMapTableBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "StackMapTableDeclaration_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // TABLES LBRACKET
  //                   ExceptionTableDeclaration?
  //                   LocVarTableDeclaration?
  //                   LocVarTypeTableDeclaration?
  //                   StackMapTableDeclaration?
  //               RBRACKET
  public static boolean TableArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TableArea")) return false;
    if (!nextTokenIs(b, TABLES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, TABLES, LBRACKET);
    r = r && TableArea_2(b, l + 1);
    r = r && TableArea_3(b, l + 1);
    r = r && TableArea_4(b, l + 1);
    r = r && TableArea_5(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, TABLE_AREA, r);
    return r;
  }

  // ExceptionTableDeclaration?
  private static boolean TableArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TableArea_2")) return false;
    ExceptionTableDeclaration(b, l + 1);
    return true;
  }

  // LocVarTableDeclaration?
  private static boolean TableArea_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TableArea_3")) return false;
    LocVarTableDeclaration(b, l + 1);
    return true;
  }

  // LocVarTypeTableDeclaration?
  private static boolean TableArea_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TableArea_4")) return false;
    LocVarTypeTableDeclaration(b, l + 1);
    return true;
  }

  // StackMapTableDeclaration?
  private static boolean TableArea_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TableArea_5")) return false;
    StackMapTableDeclaration(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // (LambdaType | JType | PRIMITIVETYPE)('[]')*
  public static boolean Type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TYPE, "<type>");
    r = Type_0(b, l + 1);
    r = r && Type_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // LambdaType | JType | PRIMITIVETYPE
  private static boolean Type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_0")) return false;
    boolean r;
    r = LambdaType(b, l + 1);
    if (!r) r = JType(b, l + 1);
    if (!r) r = consumeToken(b, PRIMITIVETYPE);
    return r;
  }

  // ('[]')*
  private static boolean Type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Type_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Type_1", c)) break;
    }
    return true;
  }

  // ('[]')
  private static boolean Type_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "[]");
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // THROWS (JType COMMA?)*
  static boolean exceptionList(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList")) return false;
    if (!nextTokenIs(b, THROWS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, THROWS);
    r = r && exceptionList_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (JType COMMA?)*
  private static boolean exceptionList_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!exceptionList_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "exceptionList_1", c)) break;
    }
    return true;
  }

  // JType COMMA?
  private static boolean exceptionList_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && exceptionList_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean exceptionList_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // Annotation* ClassHead AttributesArea? FieldArea? MethodArea?
  static boolean item_(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item_")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = item__0(b, l + 1);
    r = r && ClassHead(b, l + 1);
    r = r && item__2(b, l + 1);
    r = r && item__3(b, l + 1);
    r = r && item__4(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation*
  private static boolean item__0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "item__0", c)) break;
    }
    return true;
  }

  // AttributesArea?
  private static boolean item__2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__2")) return false;
    AttributesArea(b, l + 1);
    return true;
  }

  // FieldArea?
  private static boolean item__3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__3")) return false;
    FieldArea(b, l + 1);
    return true;
  }

  // MethodArea?
  private static boolean item__4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__4")) return false;
    MethodArea(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // item_
  static boolean jbcFile(PsiBuilder b, int l) {
    return item_(b, l + 1);
  }

  /* ********************************************************** */
  // LBRACKET( ("]")* STRINGVAR COLON*)*RBRACKET
  public static boolean lambdaParams(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams")) return false;
    if (!nextTokenIs(b, LBRACKET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && lambdaParams_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, LAMBDA_PARAMS, r);
    return r;
  }

  // ( ("]")* STRINGVAR COLON*)*
  private static boolean lambdaParams_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!lambdaParams_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1", c)) break;
    }
    return true;
  }

  // ("]")* STRINGVAR COLON*
  private static boolean lambdaParams_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = lambdaParams_1_0_0(b, l + 1);
    r = r && consumeToken(b, STRINGVAR);
    r = r && lambdaParams_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ("]")*
  private static boolean lambdaParams_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!lambdaParams_1_0_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1_0_0", c)) break;
    }
    return true;
  }

  // ("]")
  private static boolean lambdaParams_1_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "]");
    exit_section_(b, m, null, r);
    return r;
  }

  // COLON*
  private static boolean lambdaParams_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, COLON)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1_0_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // (LBRACKET(Annotation? Type COMMA?)*RBRACKET)?
  public static boolean params(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params")) return false;
    Marker m = enter_section_(b, l, _NONE_, PARAMS, "<params>");
    params_0(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  // LBRACKET(Annotation? Type COMMA?)*RBRACKET
  private static boolean params_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && params_0_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // (Annotation? Type COMMA?)*
  private static boolean params_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!params_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "params_0_1", c)) break;
    }
    return true;
  }

  // Annotation? Type COMMA?
  private static boolean params_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = params_0_1_0_0(b, l + 1);
    r = r && Type(b, l + 1);
    r = r && params_0_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation?
  private static boolean params_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_0")) return false;
    Annotation(b, l + 1);
    return true;
  }

  // COMMA?
  private static boolean params_0_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_2")) return false;
    consumeToken(b, COMMA);
    return true;
  }

}
