{
  parserClass="JavaByteCodeLanguage.parser.JavaByteCodeParser"
  parserUtilClass="JavaByteCodeLanguage.parser.JavaByteCodeParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="JavaByteCode"
  psiImplClassSuffix="Impl"
  psiPackage="JavaByteCodeLanguage.psi"
  psiImplPackage="JavaByteCodeLanguage.psi.impl"

  elementTypeHolderClass="JavaByteCodeLanguage.psi.JavaByteCodeTypes"
  elementTypeClass="JavaByteCodeLanguage.psi.JavaByteCodeElementType"
  tokenTypeClass="JavaByteCodeLanguage.psi.JavaByteCodeTokenType"
  //implements("") = "org.intellij.lang."
  tokens=[
  COMMENT='regexp://.*'
  NUMBER ='regexp:(-)?\d+'
  STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

  INST="regexp:A(A)?(CONST_NULL|LOAD|STORE)(_\d)?|(I)(CONST|LOAD|STORE)(_M?\d)?|(I|L|F|D|A)?RETURN|INVOKE(SPECIAL|STATIC|VIRTUAL)|DUP|NOP|IF(EQ|NE|LT|GE|GT|LE|_ICMP(EQ|NE|LT|GE|GT|LE)|_ACMP(EQ|NE))|IINC|ARRAYLENGTH|GOTO|NEW|CHECKCAST"
  // CONST
  SPACE='regexp:\s+'
  COMMA=","
  DOT="."
  TO="regexp:>|=>"
  LBRACKET="regexp:\(|\{|\[|«"
  RBRACKET="regexp:\)|\}|\]|»"
  CONSTMETHODNAMES = "regexp:<(cl)?init>"
  PUT_GET_INSTR="regexp:(put|get) .* :"
  LOAD_INSTR="regexp:Load([A-Za-z]+)"
  //JAVACONST
  CLASS='class'
  EXTENDS='extends'
  IMPLEMENTS='implements'
  FIELDS='Fields'
  // TYPES
  PRIMITIVETYPE="regexp:void|boolean|byte|char|short|int|long|float|double"
  MODIFIER="regexp:static|final|abstract|default"
  PREMODIFIER="regexp:public|private|protected|default"
  EOF = "\n"
  STRINGVAR = "regexp:[a-zA-Z$_][a-zA-Z0-9$_]*"

  ]

  psiImplUtilClass="JavaByteCodeLanguage.psi.impl.JavaByteCodePsiImplUtil"

//  mixin("JAVATYPE")="JavaByteCodeLanguage.psi.impl.JavaByteCodeNamedElementImpl"
//        implements="JavaByteCodeLanguage.psi.JavaByteCodeNamedElement"
//        methods=[getKey getValue getName setName getNameIdentifier getReferences]
}
jbcFile ::=  item_

private item_ ::= ClassHead FieldsDeclaration MethodDeclaration*
Type ::= (JType | PRIMITIVETYPE)('[]')*
JType ::= (STRINGVAR'.')*STRINGVAR  {mixin="JavaByteCodeLanguage.psi.impl.JavaByteCodeNamedElementImpl"
                    implements="JavaByteCodeLanguage.psi.JavaByteCodeNamedElement"
                    methods=[getJavaType getName setName getNameIdentifier getReferences]}

MethodDeclaration ::= MethodHead InstructionHead InstructionBody* LocVarTableDeclaration? {mixin="JavaByteCodeLanguage.psi.impl.JavaByteCodeNamedElementImpl"
                                                                                            implements="JavaByteCodeLanguage.psi.JavaByteCodeNamedElement"
                                                                                            methods=[getName setName getNameIdentifier getPresentation navigate]}
FieldsDeclaration ::= Fields (Type DefMethodName)*
ClassHead ::= ModifierV? class DefMethodName (extends JType)? (implements (JType(",")?)+)?
Private MethodHead ::= ModifierV? Type MethodName ("«" (STRINGVAR ","?)* "»")? // JAVA
ModifierV ::= (PREMODIFIER)?(MODIFIER)*
MethodName ::=  ('<init>'|'<clinit>'|DefMethodName) params
DefMethodName ::= STRINGVAR {mixin="JavaByteCodeLanguage.psi.impl.JavaByteCodeNamedElementImpl"
                             implements="JavaByteCodeLanguage.psi.JavaByteCodeNamedElement"
                             methods=[getStringVar getName setName getNameIdentifier getReferences]}
params ::= ('('(Type ','?)*')')?

private InstructionHead ::= PC Line Instruction
private InstructionBody::= NUMBER NUMBER Instr
Instr ::= ((INST|LOAD_INSTR) ("("((JavaOP|NUMBER|STRING)','?)*")"|JavaOP)?) | (PUT_GET_INSTR Type) | // TODO {recoverWhile=recoverTillNextInstr}
JavaOP ::= ((Type|STRINGVAR)('{'Type MethodName'}')?)+| 'lvIndex=' NUMBER

    private recoverTillNextInstr ::= !NUMBER

LocVarTableDeclaration ::= LocVarTableHead LocVarTableBody* {mixin="JavaByteCodeLanguage.psi.impl.JavaByteCodeNamedElementImpl"
                                                                               implements="JavaByteCodeLanguage.psi.JavaByteCodeNamedElement"
                                                                               methods=[getName setName getNameIdentifier getPresentation navigate]}

LocVarTableHead ::= LocalVariableTable
private LocVarTableBody ::= "["NUMBER ">" NUMBER ")" "=>" Type (this | STRINGVAR) // NOT RIGHT