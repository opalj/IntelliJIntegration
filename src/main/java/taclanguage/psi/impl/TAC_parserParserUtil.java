package taclanguage.psi.impl;

import Editors.FileEditor.TacTextEditor;
import JavaByteCodeLanguage.psi.impl.JavaByteCodePsiImplUtil;
import com.intellij.ide.util.PsiNavigationSupport;
import com.intellij.lang.ASTNode;
import com.intellij.lang.parser.GeneratedParserUtilBase;
import com.intellij.navigation.ColoredItemPresentation;
import com.intellij.navigation.ItemPresentation;
import com.intellij.openapi.editor.colors.TextAttributesKey;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.FileEditorManager;
import com.intellij.openapi.util.Iconable;
import com.intellij.pom.Navigatable;
import com.intellij.psi.*;
import com.intellij.psi.impl.source.resolve.reference.ReferenceProvidersRegistry;
import com.intellij.psi.impl.source.resolve.reference.impl.providers.JavaClassReferenceProvider;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import taclanguage.autogenerated.psi.*;
import taclanguage.psi.TACNamedElement;

/**
 * A utility class that serves as a delegate for our PSI-elements that are automatically generated
 * by the parser.
 *
 * <p>(In the grammar, see TAC.bnf file, we can define methods for selected tree elements. Since
 * they are generated by the parser, we delegate the implementations to this utility class, so that
 * the definitions aren't lost when re-generating the code.)
 */
public class TAC_parserParserUtil extends GeneratedParserUtilBase {

  private static final Logger LOGGER = Logger.getLogger(JavaByteCodePsiImplUtil.class.getName());

  /**
   * @param element a Java type, i.e. a class type (e.g. java.lang.String)
   * @return the String representation of the type
   */
  @Nullable
  public static String getJavaType(@NotNull TACJType element) {
    ASTNode javaTypeNode = element.getNode();
    if (javaTypeNode != null) {
      // IMPORTANT: Convert embedded escaped spaces to simple spaces
      return javaTypeNode.getText().replaceAll("\\\\ ", " ");
    }

    return null;
  }

  /**
   * @param element an invoked method, e.g. println in java.io.PrintStream { void println() }
   * @return the name of the method as a String (e.g. "println")
   */
  @Nullable
  public static String getStringVar(@NotNull TACDefMethodName element) {
    ASTNode stringVarNode = element.getNode().findChildByType(TAC_elementTypeHolder.STRINGVAR);
    if (stringVarNode != null) {
      // IMPORTANT: Convert embedded escaped spaces to simple spaces
      return stringVarNode.getText().replaceAll("\\\\", " ");
    }

    return null;
  }

  public static String getName(TACJType element) {
    return getJavaType(element);
  }

  public static String getName(TACDefMethodName element) {
    return getStringVar(element);
  }

  public static String getName(TACMethodDeclaration element) {
    return element.getMethodHead().getText();
  }

  public static String getName(TACFieldsDeclaration element) {
    return element.getDefMethodName().getText();
  }

  /** @see PsiNameIdentifierOwner#getNameIdentifier() */
  @Nullable
  public static PsiElement getNameIdentifier(@NotNull TACJType element) {
    ASTNode keyNode = element.getNode();
    if (keyNode != null) {
      return keyNode.getPsi();
    } else {
      return null;
    }
  }

  /** @see PsiNameIdentifierOwner#getNameIdentifier() */
  @Nullable
  public static PsiElement getNameIdentifier(@NotNull TACDefMethodName element) {
    ASTNode keyNode = element.getNode().findChildByType(TAC_elementTypeHolder.STRINGVAR);
    if (keyNode != null) {
      return keyNode.getPsi();
    } else {
      return null;
    }
  }

  /** @see PsiNameIdentifierOwner#getNameIdentifier() */
  public static PsiElement getNameIdentifier(@NotNull TACFieldsDeclaration element) {
    ASTNode keyNode = element.getDefMethodName().getNode();
    if (keyNode != null) {
      return keyNode.getPsi();
    } else {
      return null;
    }
  }

  /** @see PsiNameIdentifierOwner#getNameIdentifier() */
  public static PsiElement getNameIdentifier(@NotNull TACMethodDeclaration element) {
    ASTNode keyNode = element.getMethodHead().getNode();
    if (keyNode != null) {
      return keyNode.getPsi();
    } else {
      return null;
    }
  }
  /**
   * @see PsiElement#getReferences() for further details
   * @see com.intellij.psi.PsiReferenceRegistrar for further details
   * @param element a class type (as FQN, e.g. java.lang.String)
   * @return the references to each element in the FQN (e.g. ["java", "lang", "String"])
   */
  public static PsiReference[] getReferences(TACJType element) {
    JavaClassReferenceProvider provider = new JavaClassReferenceProvider();
    try {
      return provider.getReferencesByString(element.getName(), element, 0);
    } catch (Exception e) {
      try {
        return element.getReferences();
      } catch (StackOverflowError soe) {
        LOGGER.log(Level.SEVERE, soe.toString(), soe);
        return null;
      }
    }
  }

  /**
   * @see PsiElement#getReferences() for further details
   * @param element an invoked method in our TAC-Editor
   * @return the Java-references to this method
   */
  @NotNull
  public static PsiReference[] getReferences(TACDefMethodName element) {
    return ReferenceProvidersRegistry.getReferencesFromProviders(element);
  }

  public static ItemPresentation getPresentation(TACMethodDeclaration element) {
    return new ColoredItemPresentation() {
      private final TACMethodHead methodHead = element.getMethodHead();

      @Override
      public String getPresentableText() {
        return methodHead.getMethodName().getText() + ":" + methodHead.getType().getText();
      }

      @Nullable
      @Override
      public String getLocationString() {
        return null;
      }

      @Override
      public Icon getIcon(boolean unused) {
        int flags = Iconable.ICON_FLAG_READ_STATUS | Iconable.ICON_FLAG_VISIBILITY;
        try {
          String helpinger =
              methodHead.getModifierV().getText().length() == 0
                  ? methodHead.getType().getText()
                  : methodHead.getModifierV().getText() + " " + methodHead.getType().getText();
          return PsiElementFactory.SERVICE
              .getInstance(element.getProject())
              .createMethodFromText(helpinger + " method()", null)
              .getIcon(flags);
        } catch (Exception e) {
          return null;
        }
      }

      @Nullable
      @Override
      public TextAttributesKey getTextAttributesKey() {
        return null;
      }
    };
  }

  public static ItemPresentation getPresentation(TACFieldsDeclaration element) {
    return new ColoredItemPresentation() {
      @Nullable
      @Override
      public String getPresentableText() {
        return element.getDefMethodName().getText() + " : " + element.getType().getText();
      }

      @Nullable
      @Override
      public String getLocationString() {
        return null;
      }

      @Nullable
      @Override
      public Icon getIcon(boolean unused) {
        int flags = Iconable.ICON_FLAG_READ_STATUS | Iconable.ICON_FLAG_VISIBILITY;
        try {
          return PsiElementFactory.SERVICE
              .getInstance(element.getProject())
              .createFieldFromText(element.getText(), null)
              .getIcon(flags);
        } catch (Exception e) {
          // just a warning because a not found methodicon dont mess up the structview
          // LOGGER.log(Level.WARNING,e.toString(),e);
          return null;
        }
      }

      @Nullable
      @Override
      public TextAttributesKey getTextAttributesKey() {
        return null;
      }
    };
  }

  public static void navigate(TACMethodDeclaration element, boolean requestFocus) {
    navigate((TACNamedElement) element, requestFocus);
  }

  public static void navigate(TACFieldsDeclaration element, boolean requestFocus) {
    navigate((TACNamedElement) element, requestFocus);
  }

  private static void navigate(TACNamedElement element, boolean requestFocus) {
    Navigatable descriptor = PsiNavigationSupport.getInstance().getDescriptor(element);
    FileEditor editor = FileEditorManager.getInstance(element.getProject()).getSelectedEditor();
    if (editor instanceof TacTextEditor || descriptor != null) {
      ((TacTextEditor) editor).navigateTo(descriptor);
    } else {
      ((Navigatable) element).navigate(requestFocus);
    }
  }
}
