/*
 *  BSD 2-Clause License - see ./LICENSE for details.
 */

{
  parserClass="taclanguage.autogenerated.parser.TAC_parser"
  parserUtilClass="taclanguage.autogenerated.parser.TAC_parserParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TAC"
  psiImplClassSuffix="Impl"

  psiPackage="taclanguage.autogenerated.psi"
  psiImplPackage="taclanguage.autogenerated.psi.impl"

  elementTypeHolderClass="taclanguage.autogenerated.psi.TAC_elementTypeHolder"
  elementTypeClass="taclanguage.autogenerated.psi.TAC_elementType"
  tokenTypeClass="taclanguage.autogenerated.psi.TAC_tokenType"


  tokens=[
  WHITE_SPACE="regexp:\s"
  COMMENT='regexp://.*|/\*[^*/]*\*/'
  NUMBER ='regexp:[-]?\d+(\.\d*)?([Efdl]\d*)?'
  STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
  // CONST
  COMMA=","
  DOT="."
  COLON=":"
  SEMICOLON=";"
  //SLASH="/"
  AT="@"
  EQ="="
  SWITCH="⤼"
  LBRACKET="regexp:\(|\{|\[|[«]"
  RBRACKET="regexp:\)|\}|\]|[»]"
  JAVATYPEHEAD='regexp:class|enum|interface'
  EXTENDS='extends'
  IMPLEMENTS='implements'
  THROWS='throws'
  ATTRIBUTES='Attributes'
  FIELDS='Fields'
  METHODS='Methods'
  INSTRUCTIONHEAD="regexp:PC\s+Line\s+Instruction"
  LVLINDEX = "lvIndex="
  BOOLS='regexp:true|false'
  PRIMITIVETYPE="regexp:void|boolean|byte|char|short|int|long|float|double"
  KEYWORDS="regexp:new|goto|if|else|throw|throws|catch|caught|return"
  MODIFIER="regexp:public|private|protected|default|static|final|abstract|synchronized|native|strictfp|volatile|transient"
  LEVEL="regexp:\{?((lv|param|exception(\[VM\])?@)([A-Za-z0-9])*(,\s)?)*\}?"
  OPERATORS="regexp:\+|\-|\*|\&|\||\^|<<|>>|%|/|cmp" // added % and /
  COMPARATORS="regexp:<=|>=|==|\!=|<|>"
  STRINGVAR = "regexp:<?[a-zA-Z$_][a-zA-Z0-9$_<>]*>?"
  ]

  psiImplUtilClass="taclanguage.psi.impl.TAC_parserParserUtil"
}
jbcFile ::=  item_

private item_ ::= Annotation* ClassHead LBRACKET AttributesArea? FieldArea? MethodArea? RBRACKET

ClassHead ::= ModifierV? (AT?) JAVATYPEHEAD JType (EXTENDS JType)? (IMPLEMENTS (JType(COMMA)?)+)?

// generic stuff

// not as critical as for JBC
private TacTokens ::=  ATTRIBUTES | METHODS | FIELDS

// e.g. @Contract (pure = true) or @Contract ("_, null -> null")
Annotation ::= AT JType [LBRACKET
                            (
                                STRING COMMA?
                              | STRINGVAR EQ STRING COMMA?
                              | STRINGVAR EQ BOOLS COMMA?
                              | STRINGVAR EQ JType COMMA?
                              | STRINGVAR EQ NUMBER COMMA?
                              | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER) COMMA?)* RBRACKET COMMA?
                              | LBRACKET? Annotation RBRACKET? COMMA?
                            )*
                         RBRACKET]

ModifierV ::= MODIFIER*

Type ::= (LambdaType | JType | PRIMITIVETYPE)('[]')*
JType ::= ((STRINGVAR | TacTokens) DOT)*(STRINGVAR | TacTokens|'class')
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getJavaType getName getNameIdentifier getReferences]
}

// lambda.InnerVsLambdaThis$<init>()V:5$Lambda{ lambda.InnerVsLambdaThis$<init>()V:5$Lambda $newInstance(lambda.InnerVsLambdaThis) }
LambdaType ::= ((STRINGVAR | TacTokens) DOT)*(STRINGVAR | TacTokens) lambdaParams (STRINGVAR | TacTokens) COLON* NUMBER (STRINGVAR | TacTokens)
lambdaParams ::= (LBRACKET( ("]")* (STRINGVAR | TacTokens) COLON*)*RBRACKET)

// attributes

AttributesArea ::= ATTRIBUTES LBRACKET InnerTable? RBRACKET

InnerTable ::= STRINGVAR LBRACKET
                    (Type LBRACKET ModifierV (AT?) JAVATYPEHEAD? STRINGVAR RBRACKET)*
               RBRACKET

// fields

FieldArea ::= FIELDS LBRACKET FieldsDeclaration* RBRACKET

FieldsDeclaration ::= ModifierV? Type DefMethodName
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getName getNameIdentifier getPresentation navigate]
}

// methods

MethodArea ::= METHODS LBRACKET MethodDeclaration* RBRACKET

// method body is optional (in case of abstract methods
MethodDeclaration ::= Annotation* MethodHead LBRACKET
         InstructionBody*
        RBRACKET
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getName getNameIdentifier getPresentation navigate]
}

MethodHead ::= ModifierV? Type MethodName  // JAVA

MethodName ::=  DefMethodName params exceptionList*
DefMethodName ::= STRINGVAR
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getStringVar getName getNameIdentifier getReferences]
}
params ::= (LBRACKET((Annotation* Type | LEVEL ) COMMA?)*RBRACKET)?
private exceptionList ::= THROWS (JType COMMA?)*

// instructions (part of method body)
InstructionBody ::= InstNumber COLON Instr
InstNumber ::= NUMBER
//Instr ::=(STRING|NUMBER|ifInst|switchInst|gotoInst|KEYWORDS|PRIMITIVETYPE|MODIFIER|EXTENDS|IMPLEMENTS|JAVATYPEHEAD|THROW|THROWS|VOID|THIS|LEVEL|COMMA|DOT|SEMICOLON|COLON|AT|R_ARROW|L_ARROW|"[]"|"("|")"|"["|"]"|"%"|COMPARATORS|DIVID|OPERATORS|CONSTMETHODNAMES|EQ|UEQ|STRINGVAR|PLUS|MINUS)*
Instr::= ifInst|switchInst|gotoInst|MonitorInst|EQInstr|MethodCallOrNEWInstr|CastIntr|CaughtInst|KEYWORDS[LEVEL]|";"
EQInstr ::= LeftSide EQ RightSide [(OPERATORS) RightSide]
LeftSide ::=  Levels| JType
RightSide ::= (MethodCallOrNEWInstr| Levels |CastIntr| STRING | NUMBER )
Levels ::= LEVEL [DOT JType|"instanceof" JType] ArrayOrBracket
MethodCallOrNEWInstr ::=  [KEYWORDS|LEVEL DOT] (JType|PRIMITIVETYPE) ArrayOrBracket LambdaSuffix // get better name
CastIntr::= LBRACKET (JType ["[]"]|PRIMITIVETYPE) RBRACKET  LEVEL
CaughtInst ::= KEYWORDS JType
MonitorInst ::= ("monitorenter"|"monitorexit") Levels
LambdaSuffix ::= [JType"::"NUMBER?JType ArrayOrBracket]
ArrayOrBracket ::= [LBRACKET ((LEVEL|JType ":") COMMA?)* RBRACKET]

switchInst ::= "switch" LBRACKET LEVEL RBRACKET LBRACKET((NUMBER|"default") COLON gotoInst SEMICOLON?)* RBRACKET
//Instr ::= ifInst| gotoInst|LBRACKET LeftSideInstr RBRACKET RightSideInstr |SEMICOLON|LeftSideInstr (EQ  RightSideInstr)? |
ifInst ::= "if" LBRACKET LEVEL ("<="|">="|"<"|">"|"=="|"!=") (NUMBER|LEVEL|"null") RBRACKET gotoInst
gotoInst ::= "goto" NUMBER
//newInst ::= "new" Type LBRACKET LEVEL RBRACKET
//LeftSideInstr ::=  ( LEVEL |Type | PRIMITIVETYPE | KEYWORDS) (LEVEL|JType| DOT? MethodName)?
//RightSideInstr::=  ( LEVEL |NUMBER |STRING| Type | PRIMITIVETYPE | newInst| KEYWORDS )(LEVEL| DOT MethodName|JType|params)? [OPRATORS RightSideInstr]