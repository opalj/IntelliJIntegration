{
  parserClass="taclanguage.autogenerated.parser.TAC_parser"
  parserUtilClass="taclanguage.autogenerated.parser.TAC_parserParserUtil"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="TAC"
  psiImplClassSuffix="Impl"

  psiPackage="taclanguage.autogenerated.psi"
  psiImplPackage="taclanguage.autogenerated.psi.impl"

  elementTypeHolderClass="taclanguage.autogenerated.psi.TAC_elementTypeHolder"
  elementTypeClass="taclanguage.autogenerated.psi.TAC_elementType"
  tokenTypeClass="taclanguage.autogenerated.psi.TAC_tokenType"


  tokens=[
  COMMENT='regexp://.*|/\*[^*/]*\*/'
  NUMBER ='regexp:[-]?\d+(\.\d*)?([Efdl]\d*)?'
  STRING="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
  // CONST
  COMMA=","
  DOT="."
  COLON=":"
  SEMICOLON=";"
  SLASH="/"
  AT="@"
  //Todo Merge ">" right
  //TO="regexp:>|=>|->"
  EQ="="
  SWITCH="⤼"
  LBRACKET="regexp:\(|\{|\[|[«]"
  RBRACKET="regexp:\)|\}|\]|[»]"
  //JAVACONST
  JAVATYPEHEAD='regexp:class|enum|interface'
  EXTENDS='extends'
  IMPLEMENTS='implements'
  THROWS='throws'
  ATTRIBUTES='Attributes'
  FIELDS='Fields'
  METHODS='Methods'
  INSTRUCTIONHEAD="regexp:PC\s+Line\s+Instruction"
  LVLINDEX = "lvIndex="
  // TYPES
  PRIMITIVETYPE="regexp:void|boolean|byte|char|short|int|long|float|double"
  KEYWORDS="regexp:new|goto|if|else|throw|throws|catch|caught|return"
  MODIFIER="regexp:public|private|protected|default|static|final|abstract|synchronized|native|strictfp|volatile|transient"
  LEVEL="regexp:\{?((lv|param|exception(\[VM\])?@)([A-Za-z0-9])*(,\s)?)*\}?"
  OPERATORS="regexp:\+|\-|\*|\&|\||\^|<<|>>"
  COMPARATORS="regexp:<=|>=|==|\!=|<|>"
  STRINGVAR = "regexp:<?[a-zA-Z$_][a-zA-Z0-9$_<>]*>?"
  ]

  psiImplUtilClass="taclanguage.psi.impl.TAC_parserParserUtil"
}
jbcFile ::=  item_

private item_ ::= Annotation* ClassHead AttributesArea? FieldArea? MethodArea?

ClassHead ::= ModifierV? (AT?) JAVATYPEHEAD JType (EXTENDS JType)? (IMPLEMENTS (JType(COMMA)?)+)?

// generic stuff

Annotation ::= AT JType

ModifierV ::= MODIFIER*

Type ::= (LambdaType | JType | PRIMITIVETYPE)('[]')*
JType ::= (STRINGVAR DOT)*STRINGVAR
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getJavaType getName getNameIdentifier getReferences]
}

// lambda.InnerVsLambdaThis$<init>()V:5$Lambda{ lambda.InnerVsLambdaThis$<init>()V:5$Lambda $newInstance(lambda.InnerVsLambdaThis) }
LambdaType ::= (STRINGVAR DOT)*STRINGVAR lambdaParams STRINGVAR COLON* NUMBER STRINGVAR
lambdaParams ::= (LBRACKET( ("]")* STRINGVAR COLON*)*RBRACKET)

// attributes

AttributesArea ::= ATTRIBUTES LBRACKET InnerTable? RBRACKET

InnerTable ::= STRINGVAR LBRACKET
                    (Type LBRACKET ModifierV JAVATYPEHEAD? STRINGVAR RBRACKET)*
               RBRACKET

// fields

FieldArea ::= FIELDS LBRACKET FieldsDeclaration* RBRACKET

FieldsDeclaration ::= ModifierV? Type DefMethodName
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getName getNameIdentifier getPresentation navigate]
}

// methods

MethodArea ::= METHODS LBRACKET MethodDeclaration* RBRACKET

// method body is optional (in case of abstract methods
MethodDeclaration ::= Annotation* MethodHead LBRACKET
         InstructionBody*
        RBRACKET
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getName getNameIdentifier getPresentation navigate]
}

MethodHead ::= ModifierV? Type MethodName  // JAVA

MethodName ::=  DefMethodName params exceptionList*
DefMethodName ::= STRINGVAR
{
 mixin="taclanguage.psi.impl.TACNamedElementImpl"
 implements="taclanguage.psi.TACNamedElement"
 methods=[getStringVar getName getNameIdentifier getReferences]
}
params ::= (LBRACKET((Annotation? Type | LEVEL ) COMMA?)*RBRACKET)?
private exceptionList ::= THROWS (JType COMMA?)*

// instructions (part of method body)
private InstructionBody ::= NUMBER COLON Instr
//TODO "/" cant be tokenized
Instr ::=(STRING|NUMBER|switchInst|KEYWORDS|PRIMITIVETYPE|MODIFIER|EXTENDS|IMPLEMENTS|CLASS|THROW|THROWS|VOID|THIS|LEVEL|COMMA|DOT|SEMICOLON|COLON|AT|R_ARROW|L_ARROW|"("|")"|"["|"]"|COMPARATORS|"/"|COMPARATORS|OPERATORS|CONSTMETHODNAMES|EQ|UEQ|STRINGVAR|PLUS|MINUS)*
switchInst ::= "switch" LBRACKET LEVEL RBRACKET LBRACKET((NUMBER|"default") COLON "goto" NUMBER SEMICOLON?)* RBRACKET
//Instr ::= ifInst| gotoInst|LBRACKET LeftSideInstr RBRACKET RightSideInstr |SEMICOLON|LeftSideInstr (EQ  RightSideInstr)? |
//ifInst ::= "if" LBRACKET LEVEL ("<="|">="|"<"|">"|"=="|"!=") (NUMBER|LEVEL) RBRACKET gotoInst
//gotoInst ::= "goto" NUMBER
//newInst ::= "new" Type LBRACKET LEVEL RBRACKET
//LeftSideInstr ::=  ( LEVEL |Type | PRIMITIVETYPE | KEYWORDS) (LEVEL|JType| DOT? MethodName)?
//RightSideInstr::=  ( LEVEL |NUMBER |STRING| Type | PRIMITIVETYPE | newInst| KEYWORDS )(LEVEL| DOT MethodName|JType|params)? [OPRATORS RightSideInstr]