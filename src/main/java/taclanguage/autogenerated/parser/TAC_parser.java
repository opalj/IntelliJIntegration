// This is a generated file. Not intended for manual editing.
package taclanguage.autogenerated.parser;

import static taclanguage.autogenerated.parser.TAC_parserParserUtil.*;
import static taclanguage.autogenerated.psi.TAC_elementTypeHolder.*;

import com.intellij.lang.ASTNode;
import com.intellij.lang.LightPsiParser;
import com.intellij.lang.PsiBuilder;
import com.intellij.lang.PsiBuilder.Marker;
import com.intellij.lang.PsiParser;
import com.intellij.psi.tree.IElementType;
import com.intellij.psi.tree.IFileElementType;

@SuppressWarnings({"SimplifiableIfStatement", "UnusedAssignment"})
public class TAC_parser implements PsiParser, LightPsiParser {

  public ASTNode parse(IElementType t, PsiBuilder b) {
    parseLight(t, b);
    return b.getTreeBuilt();
  }

  public void parseLight(IElementType t, PsiBuilder b) {
    boolean r;
    b = adapt_builder_(t, b, this, null);
    Marker m = enter_section_(b, 0, _COLLAPSE_, null);
    if (t instanceof IFileElementType) {
      r = parse_root_(t, b, 0);
    } else {
      r = false;
    }
    exit_section_(b, 0, m, t, r, true, TRUE_CONDITION);
  }

  protected boolean parse_root_(IElementType t, PsiBuilder b, int l) {
    return jbcFile(b, l + 1);
  }

  /* ********************************************************** */
  // AT JType [LBRACKET
  //                             (
  //                                 STRING COMMA?
  //                               | STRINGVAR EQ STRING COMMA?
  //                               | STRINGVAR EQ BOOLS COMMA?
  //                               | STRINGVAR EQ JType COMMA?
  //                               | STRINGVAR EQ NUMBER COMMA?
  //                               | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER)
  // COMMA?)* RBRACKET COMMA?
  //                               | LBRACKET? Annotation RBRACKET? COMMA?
  //                             )*
  //                          RBRACKET]
  public static boolean Annotation(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation")) return false;
    if (!nextTokenIs(b, AT)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, AT);
    r = r && JType(b, l + 1);
    r = r && Annotation_2(b, l + 1);
    exit_section_(b, m, ANNOTATION, r);
    return r;
  }

  // [LBRACKET
  //                             (
  //                                 STRING COMMA?
  //                               | STRINGVAR EQ STRING COMMA?
  //                               | STRINGVAR EQ BOOLS COMMA?
  //                               | STRINGVAR EQ JType COMMA?
  //                               | STRINGVAR EQ NUMBER COMMA?
  //                               | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER)
  // COMMA?)* RBRACKET COMMA?
  //                               | LBRACKET? Annotation RBRACKET? COMMA?
  //                             )*
  //                          RBRACKET]
  private static boolean Annotation_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2")) return false;
    Annotation_2_0(b, l + 1);
    return true;
  }

  // LBRACKET
  //                             (
  //                                 STRING COMMA?
  //                               | STRINGVAR EQ STRING COMMA?
  //                               | STRINGVAR EQ BOOLS COMMA?
  //                               | STRINGVAR EQ JType COMMA?
  //                               | STRINGVAR EQ NUMBER COMMA?
  //                               | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER)
  // COMMA?)* RBRACKET COMMA?
  //                               | LBRACKET? Annotation RBRACKET? COMMA?
  //                             )*
  //                          RBRACKET
  private static boolean Annotation_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && Annotation_2_0_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // (
  //                                 STRING COMMA?
  //                               | STRINGVAR EQ STRING COMMA?
  //                               | STRINGVAR EQ BOOLS COMMA?
  //                               | STRINGVAR EQ JType COMMA?
  //                               | STRINGVAR EQ NUMBER COMMA?
  //                               | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER)
  // COMMA?)* RBRACKET COMMA?
  //                               | LBRACKET? Annotation RBRACKET? COMMA?
  //                             )*
  private static boolean Annotation_2_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation_2_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Annotation_2_0_1", c)) break;
    }
    return true;
  }

  // STRING COMMA?
  //                               | STRINGVAR EQ STRING COMMA?
  //                               | STRINGVAR EQ BOOLS COMMA?
  //                               | STRINGVAR EQ JType COMMA?
  //                               | STRINGVAR EQ NUMBER COMMA?
  //                               | STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER)
  // COMMA?)* RBRACKET COMMA?
  //                               | LBRACKET? Annotation RBRACKET? COMMA?
  private static boolean Annotation_2_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Annotation_2_0_1_0_0(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_1(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_2(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_3(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_4(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_5(b, l + 1);
    if (!r) r = Annotation_2_0_1_0_6(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRING COMMA?
  private static boolean Annotation_2_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STRING);
    r = r && Annotation_2_0_1_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // STRINGVAR EQ STRING COMMA?
  private static boolean Annotation_2_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, EQ, STRING);
    r = r && Annotation_2_0_1_0_1_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_1_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_1_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // STRINGVAR EQ BOOLS COMMA?
  private static boolean Annotation_2_0_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_2")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, EQ, BOOLS);
    r = r && Annotation_2_0_1_0_2_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_2_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_2_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // STRINGVAR EQ JType COMMA?
  private static boolean Annotation_2_0_1_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, EQ);
    r = r && JType(b, l + 1);
    r = r && Annotation_2_0_1_0_3_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_3_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_3_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // STRINGVAR EQ NUMBER COMMA?
  private static boolean Annotation_2_0_1_0_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, EQ, NUMBER);
    r = r && Annotation_2_0_1_0_4_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_4_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_4_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // STRINGVAR EQ LBRACKET ((STRING | BOOLS | JType | NUMBER) COMMA?)* RBRACKET COMMA?
  private static boolean Annotation_2_0_1_0_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, EQ, LBRACKET);
    r = r && Annotation_2_0_1_0_5_3(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    r = r && Annotation_2_0_1_0_5_5(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ((STRING | BOOLS | JType | NUMBER) COMMA?)*
  private static boolean Annotation_2_0_1_0_5_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5_3")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation_2_0_1_0_5_3_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Annotation_2_0_1_0_5_3", c)) break;
    }
    return true;
  }

  // (STRING | BOOLS | JType | NUMBER) COMMA?
  private static boolean Annotation_2_0_1_0_5_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Annotation_2_0_1_0_5_3_0_0(b, l + 1);
    r = r && Annotation_2_0_1_0_5_3_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRING | BOOLS | JType | NUMBER
  private static boolean Annotation_2_0_1_0_5_3_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5_3_0_0")) return false;
    boolean r;
    r = consumeToken(b, STRING);
    if (!r) r = consumeToken(b, BOOLS);
    if (!r) r = JType(b, l + 1);
    if (!r) r = consumeToken(b, NUMBER);
    return r;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_5_3_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5_3_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_5_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_5_5")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  // LBRACKET? Annotation RBRACKET? COMMA?
  private static boolean Annotation_2_0_1_0_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_6")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Annotation_2_0_1_0_6_0(b, l + 1);
    r = r && Annotation(b, l + 1);
    r = r && Annotation_2_0_1_0_6_2(b, l + 1);
    r = r && Annotation_2_0_1_0_6_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // LBRACKET?
  private static boolean Annotation_2_0_1_0_6_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_6_0")) return false;
    consumeToken(b, LBRACKET);
    return true;
  }

  // RBRACKET?
  private static boolean Annotation_2_0_1_0_6_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_6_2")) return false;
    consumeToken(b, RBRACKET);
    return true;
  }

  // COMMA?
  private static boolean Annotation_2_0_1_0_6_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Annotation_2_0_1_0_6_3")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // [LBRACKET ((LEVEL|JType ":") COMMA?)* RBRACKET]
  public static boolean ArrayOrBracket(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket")) return false;
    Marker m = enter_section_(b, l, _NONE_, ARRAY_OR_BRACKET, "<array or bracket>");
    ArrayOrBracket_0(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  // LBRACKET ((LEVEL|JType ":") COMMA?)* RBRACKET
  private static boolean ArrayOrBracket_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && ArrayOrBracket_0_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // ((LEVEL|JType ":") COMMA?)*
  private static boolean ArrayOrBracket_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!ArrayOrBracket_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "ArrayOrBracket_0_1", c)) break;
    }
    return true;
  }

  // (LEVEL|JType ":") COMMA?
  private static boolean ArrayOrBracket_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = ArrayOrBracket_0_1_0_0(b, l + 1);
    r = r && ArrayOrBracket_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // LEVEL|JType ":"
  private static boolean ArrayOrBracket_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LEVEL);
    if (!r) r = ArrayOrBracket_0_1_0_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // JType ":"
  private static boolean ArrayOrBracket_0_1_0_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0_1_0_0_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && consumeToken(b, COLON);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean ArrayOrBracket_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ArrayOrBracket_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // ATTRIBUTES LBRACKET InnerTable? RBRACKET
  public static boolean AttributesArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "AttributesArea")) return false;
    if (!nextTokenIs(b, ATTRIBUTES)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, ATTRIBUTES, LBRACKET);
    r = r && AttributesArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, ATTRIBUTES_AREA, r);
    return r;
  }

  // InnerTable?
  private static boolean AttributesArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "AttributesArea_2")) return false;
    InnerTable(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // LBRACKET (JType ["[]"]|PRIMITIVETYPE) RBRACKET  LEVEL
  public static boolean CastIntr(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "CastIntr")) return false;
    if (!nextTokenIs(b, LBRACKET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && CastIntr_1(b, l + 1);
    r = r && consumeTokens(b, 0, RBRACKET, LEVEL);
    exit_section_(b, m, CAST_INTR, r);
    return r;
  }

  // JType ["[]"]|PRIMITIVETYPE
  private static boolean CastIntr_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "CastIntr_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = CastIntr_1_0(b, l + 1);
    if (!r) r = consumeToken(b, PRIMITIVETYPE);
    exit_section_(b, m, null, r);
    return r;
  }

  // JType ["[]"]
  private static boolean CastIntr_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "CastIntr_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && CastIntr_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ["[]"]
  private static boolean CastIntr_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "CastIntr_1_0_1")) return false;
    consumeToken(b, "[]");
    return true;
  }

  /* ********************************************************** */
  // KEYWORDS JType
  public static boolean CaughtInst(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "CaughtInst")) return false;
    if (!nextTokenIs(b, KEYWORDS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, KEYWORDS);
    r = r && JType(b, l + 1);
    exit_section_(b, m, CAUGHT_INST, r);
    return r;
  }

  /* ********************************************************** */
  // ModifierV? (AT?) JAVATYPEHEAD JType (EXTENDS JType)? (IMPLEMENTS (JType(COMMA)?)+)?
  public static boolean ClassHead(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, CLASS_HEAD, "<class head>");
    r = ClassHead_0(b, l + 1);
    r = r && ClassHead_1(b, l + 1);
    r = r && consumeToken(b, JAVATYPEHEAD);
    r = r && JType(b, l + 1);
    r = r && ClassHead_4(b, l + 1);
    r = r && ClassHead_5(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean ClassHead_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  // AT?
  private static boolean ClassHead_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_1")) return false;
    consumeToken(b, AT);
    return true;
  }

  // (EXTENDS JType)?
  private static boolean ClassHead_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_4")) return false;
    ClassHead_4_0(b, l + 1);
    return true;
  }

  // EXTENDS JType
  private static boolean ClassHead_4_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_4_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, EXTENDS);
    r = r && JType(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (IMPLEMENTS (JType(COMMA)?)+)?
  private static boolean ClassHead_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5")) return false;
    ClassHead_5_0(b, l + 1);
    return true;
  }

  // IMPLEMENTS (JType(COMMA)?)+
  private static boolean ClassHead_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, IMPLEMENTS);
    r = r && ClassHead_5_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (JType(COMMA)?)+
  private static boolean ClassHead_5_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = ClassHead_5_0_1_0(b, l + 1);
    while (r) {
      int c = current_position_(b);
      if (!ClassHead_5_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "ClassHead_5_0_1", c)) break;
    }
    exit_section_(b, m, null, r);
    return r;
  }

  // JType(COMMA)?
  private static boolean ClassHead_5_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && ClassHead_5_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (COMMA)?
  private static boolean ClassHead_5_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ClassHead_5_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // STRINGVAR
  public static boolean DefMethodName(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "DefMethodName")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STRINGVAR);
    exit_section_(b, m, DEF_METHOD_NAME, r);
    return r;
  }

  /* ********************************************************** */
  // LeftSide EQ RightSide [(OPERATORS) RightSide]
  public static boolean EQInstr(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "EQInstr")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, EQ_INSTR, "<eq instr>");
    r = LeftSide(b, l + 1);
    r = r && consumeToken(b, EQ);
    r = r && RightSide(b, l + 1);
    r = r && EQInstr_3(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [(OPERATORS) RightSide]
  private static boolean EQInstr_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "EQInstr_3")) return false;
    EQInstr_3_0(b, l + 1);
    return true;
  }

  // (OPERATORS) RightSide
  private static boolean EQInstr_3_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "EQInstr_3_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, OPERATORS);
    r = r && RightSide(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // FIELDS LBRACKET FieldsDeclaration* RBRACKET
  public static boolean FieldArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldArea")) return false;
    if (!nextTokenIs(b, FIELDS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, FIELDS, LBRACKET);
    r = r && FieldArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, FIELD_AREA, r);
    return r;
  }

  // FieldsDeclaration*
  private static boolean FieldArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldArea_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!FieldsDeclaration(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "FieldArea_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // ModifierV? Type DefMethodName
  public static boolean FieldsDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldsDeclaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, FIELDS_DECLARATION, "<fields declaration>");
    r = FieldsDeclaration_0(b, l + 1);
    r = r && Type(b, l + 1);
    r = r && DefMethodName(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean FieldsDeclaration_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "FieldsDeclaration_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // STRINGVAR LBRACKET
  //                     (Type LBRACKET ModifierV (AT?) JAVATYPEHEAD? STRINGVAR RBRACKET)*
  //                RBRACKET
  public static boolean InnerTable(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, STRINGVAR, LBRACKET);
    r = r && InnerTable_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, INNER_TABLE, r);
    return r;
  }

  // (Type LBRACKET ModifierV (AT?) JAVATYPEHEAD? STRINGVAR RBRACKET)*
  private static boolean InnerTable_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!InnerTable_2_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "InnerTable_2", c)) break;
    }
    return true;
  }

  // Type LBRACKET ModifierV (AT?) JAVATYPEHEAD? STRINGVAR RBRACKET
  private static boolean InnerTable_2_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Type(b, l + 1);
    r = r && consumeToken(b, LBRACKET);
    r = r && ModifierV(b, l + 1);
    r = r && InnerTable_2_0_3(b, l + 1);
    r = r && InnerTable_2_0_4(b, l + 1);
    r = r && consumeTokens(b, 0, STRINGVAR, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // AT?
  private static boolean InnerTable_2_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2_0_3")) return false;
    consumeToken(b, AT);
    return true;
  }

  // JAVATYPEHEAD?
  private static boolean InnerTable_2_0_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InnerTable_2_0_4")) return false;
    consumeToken(b, JAVATYPEHEAD);
    return true;
  }

  /* ********************************************************** */
  // NUMBER
  public static boolean InstNumber(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InstNumber")) return false;
    if (!nextTokenIs(b, NUMBER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    exit_section_(b, m, INST_NUMBER, r);
    return r;
  }

  /* ********************************************************** */
  // ifInst|switchInst|gotoInst|MonitorInst|EQInstr|MethodCallOrNEWInstr|CastIntr|CaughtInst|KEYWORDS[LEVEL]|";"
  public static boolean Instr(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, INSTR, "<instr>");
    r = ifInst(b, l + 1);
    if (!r) r = switchInst(b, l + 1);
    if (!r) r = gotoInst(b, l + 1);
    if (!r) r = MonitorInst(b, l + 1);
    if (!r) r = EQInstr(b, l + 1);
    if (!r) r = MethodCallOrNEWInstr(b, l + 1);
    if (!r) r = CastIntr(b, l + 1);
    if (!r) r = CaughtInst(b, l + 1);
    if (!r) r = Instr_8(b, l + 1);
    if (!r) r = consumeToken(b, SEMICOLON);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // KEYWORDS[LEVEL]
  private static boolean Instr_8(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_8")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, KEYWORDS);
    r = r && Instr_8_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // [LEVEL]
  private static boolean Instr_8_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Instr_8_1")) return false;
    consumeToken(b, LEVEL);
    return true;
  }

  /* ********************************************************** */
  // InstNumber COLON Instr
  public static boolean InstructionBody(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "InstructionBody")) return false;
    if (!nextTokenIs(b, NUMBER)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = InstNumber(b, l + 1);
    r = r && consumeToken(b, COLON);
    r = r && Instr(b, l + 1);
    exit_section_(b, m, INSTRUCTION_BODY, r);
    return r;
  }

  /* ********************************************************** */
  // ((STRINGVAR | TacTokens) DOT)*(STRINGVAR | TacTokens|'class')
  public static boolean JType(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, J_TYPE, "<j type>");
    r = JType_0(b, l + 1);
    r = r && JType_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ((STRINGVAR | TacTokens) DOT)*
  private static boolean JType_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!JType_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "JType_0", c)) break;
    }
    return true;
  }

  // (STRINGVAR | TacTokens) DOT
  private static boolean JType_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType_0_0_0(b, l + 1);
    r = r && consumeToken(b, DOT);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRINGVAR | TacTokens
  private static boolean JType_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_0_0_0")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  // STRINGVAR | TacTokens|'class'
  private static boolean JType_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "JType_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    if (!r) r = consumeToken(b, "class");
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // [JType"::"NUMBER?JType ArrayOrBracket]
  public static boolean LambdaSuffix(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaSuffix")) return false;
    Marker m = enter_section_(b, l, _NONE_, LAMBDA_SUFFIX, "<lambda suffix>");
    LambdaSuffix_0(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  // JType"::"NUMBER?JType ArrayOrBracket
  private static boolean LambdaSuffix_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaSuffix_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && consumeToken(b, "::");
    r = r && LambdaSuffix_0_2(b, l + 1);
    r = r && JType(b, l + 1);
    r = r && ArrayOrBracket(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // NUMBER?
  private static boolean LambdaSuffix_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaSuffix_0_2")) return false;
    consumeToken(b, NUMBER);
    return true;
  }

  /* ********************************************************** */
  // ((STRINGVAR | TacTokens) DOT)*(STRINGVAR | TacTokens) lambdaParams (STRINGVAR | TacTokens)
  // COLON* NUMBER (STRINGVAR | TacTokens)
  public static boolean LambdaType(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LAMBDA_TYPE, "<lambda type>");
    r = LambdaType_0(b, l + 1);
    r = r && LambdaType_1(b, l + 1);
    r = r && lambdaParams(b, l + 1);
    r = r && LambdaType_3(b, l + 1);
    r = r && LambdaType_4(b, l + 1);
    r = r && consumeToken(b, NUMBER);
    r = r && LambdaType_6(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ((STRINGVAR | TacTokens) DOT)*
  private static boolean LambdaType_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!LambdaType_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "LambdaType_0", c)) break;
    }
    return true;
  }

  // (STRINGVAR | TacTokens) DOT
  private static boolean LambdaType_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = LambdaType_0_0_0(b, l + 1);
    r = r && consumeToken(b, DOT);
    exit_section_(b, m, null, r);
    return r;
  }

  // STRINGVAR | TacTokens
  private static boolean LambdaType_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_0_0_0")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  // STRINGVAR | TacTokens
  private static boolean LambdaType_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_1")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  // STRINGVAR | TacTokens
  private static boolean LambdaType_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_3")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  // COLON*
  private static boolean LambdaType_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_4")) return false;
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, COLON)) break;
      if (!empty_element_parsed_guard_(b, "LambdaType_4", c)) break;
    }
    return true;
  }

  // STRINGVAR | TacTokens
  private static boolean LambdaType_6(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LambdaType_6")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  /* ********************************************************** */
  // Levels| JType
  public static boolean LeftSide(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "LeftSide")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, LEFT_SIDE, "<left side>");
    r = Levels(b, l + 1);
    if (!r) r = JType(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // LEVEL [DOT JType|"instanceof" JType] ArrayOrBracket
  public static boolean Levels(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Levels")) return false;
    if (!nextTokenIs(b, LEVEL)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LEVEL);
    r = r && Levels_1(b, l + 1);
    r = r && ArrayOrBracket(b, l + 1);
    exit_section_(b, m, LEVELS, r);
    return r;
  }

  // [DOT JType|"instanceof" JType]
  private static boolean Levels_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Levels_1")) return false;
    Levels_1_0(b, l + 1);
    return true;
  }

  // DOT JType|"instanceof" JType
  private static boolean Levels_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Levels_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = Levels_1_0_0(b, l + 1);
    if (!r) r = Levels_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // DOT JType
  private static boolean Levels_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Levels_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, DOT);
    r = r && JType(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // "instanceof" JType
  private static boolean Levels_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Levels_1_0_1")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "instanceof");
    r = r && JType(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // METHODS LBRACKET MethodDeclaration* RBRACKET
  public static boolean MethodArea(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodArea")) return false;
    if (!nextTokenIs(b, METHODS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeTokens(b, 0, METHODS, LBRACKET);
    r = r && MethodArea_2(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, METHOD_AREA, r);
    return r;
  }

  // MethodDeclaration*
  private static boolean MethodArea_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodArea_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!MethodDeclaration(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodArea_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // [KEYWORDS|LEVEL DOT] (JType|PRIMITIVETYPE) ArrayOrBracket LambdaSuffix
  public static boolean MethodCallOrNEWInstr(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodCallOrNEWInstr")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_CALL_OR_NEW_INSTR, "<method call or new instr>");
    r = MethodCallOrNEWInstr_0(b, l + 1);
    r = r && MethodCallOrNEWInstr_1(b, l + 1);
    r = r && ArrayOrBracket(b, l + 1);
    r = r && LambdaSuffix(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // [KEYWORDS|LEVEL DOT]
  private static boolean MethodCallOrNEWInstr_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodCallOrNEWInstr_0")) return false;
    MethodCallOrNEWInstr_0_0(b, l + 1);
    return true;
  }

  // KEYWORDS|LEVEL DOT
  private static boolean MethodCallOrNEWInstr_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodCallOrNEWInstr_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, KEYWORDS);
    if (!r) r = parseTokens(b, 0, LEVEL, DOT);
    exit_section_(b, m, null, r);
    return r;
  }

  // JType|PRIMITIVETYPE
  private static boolean MethodCallOrNEWInstr_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodCallOrNEWInstr_1")) return false;
    boolean r;
    r = JType(b, l + 1);
    if (!r) r = consumeToken(b, PRIMITIVETYPE);
    return r;
  }

  /* ********************************************************** */
  // Annotation* MethodHead LBRACKET
  //          InstructionBody*
  //         RBRACKET
  public static boolean MethodDeclaration(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_DECLARATION, "<method declaration>");
    r = MethodDeclaration_0(b, l + 1);
    r = r && MethodHead(b, l + 1);
    r = r && consumeToken(b, LBRACKET);
    r = r && MethodDeclaration_3(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // Annotation*
  private static boolean MethodDeclaration_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodDeclaration_0", c)) break;
    }
    return true;
  }

  // InstructionBody*
  private static boolean MethodDeclaration_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodDeclaration_3")) return false;
    while (true) {
      int c = current_position_(b);
      if (!InstructionBody(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodDeclaration_3", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // ModifierV? Type MethodName
  public static boolean MethodHead(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodHead")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, METHOD_HEAD, "<method head>");
    r = MethodHead_0(b, l + 1);
    r = r && Type(b, l + 1);
    r = r && MethodName(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ModifierV?
  private static boolean MethodHead_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodHead_0")) return false;
    ModifierV(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // DefMethodName params exceptionList*
  public static boolean MethodName(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodName")) return false;
    if (!nextTokenIs(b, STRINGVAR)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = DefMethodName(b, l + 1);
    r = r && params(b, l + 1);
    r = r && MethodName_2(b, l + 1);
    exit_section_(b, m, METHOD_NAME, r);
    return r;
  }

  // exceptionList*
  private static boolean MethodName_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MethodName_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!exceptionList(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "MethodName_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // MODIFIER*
  public static boolean ModifierV(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ModifierV")) return false;
    Marker m = enter_section_(b, l, _NONE_, MODIFIER_V, "<modifier v>");
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, MODIFIER)) break;
      if (!empty_element_parsed_guard_(b, "ModifierV", c)) break;
    }
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  /* ********************************************************** */
  // ("monitorenter"|"monitorexit") Levels
  public static boolean MonitorInst(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MonitorInst")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, MONITOR_INST, "<monitor inst>");
    r = MonitorInst_0(b, l + 1);
    r = r && Levels(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // "monitorenter"|"monitorexit"
  private static boolean MonitorInst_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "MonitorInst_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "monitorenter");
    if (!r) r = consumeToken(b, "monitorexit");
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // MethodCallOrNEWInstr| Levels |CastIntr| STRING | NUMBER
  public static boolean RightSide(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "RightSide")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, RIGHT_SIDE, "<right side>");
    r = MethodCallOrNEWInstr(b, l + 1);
    if (!r) r = Levels(b, l + 1);
    if (!r) r = CastIntr(b, l + 1);
    if (!r) r = consumeToken(b, STRING);
    if (!r) r = consumeToken(b, NUMBER);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // ATTRIBUTES | METHODS | FIELDS
  static boolean TacTokens(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "TacTokens")) return false;
    boolean r;
    r = consumeToken(b, ATTRIBUTES);
    if (!r) r = consumeToken(b, METHODS);
    if (!r) r = consumeToken(b, FIELDS);
    return r;
  }

  /* ********************************************************** */
  // (LambdaType | JType | PRIMITIVETYPE)('[]')*
  public static boolean Type(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, TYPE, "<type>");
    r = Type_0(b, l + 1);
    r = r && Type_1(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // LambdaType | JType | PRIMITIVETYPE
  private static boolean Type_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_0")) return false;
    boolean r;
    r = LambdaType(b, l + 1);
    if (!r) r = JType(b, l + 1);
    if (!r) r = consumeToken(b, PRIMITIVETYPE);
    return r;
  }

  // ('[]')*
  private static boolean Type_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Type_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "Type_1", c)) break;
    }
    return true;
  }

  // ('[]')
  private static boolean Type_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "Type_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "[]");
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // THROWS (JType COMMA?)*
  static boolean exceptionList(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList")) return false;
    if (!nextTokenIs(b, THROWS)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, THROWS);
    r = r && exceptionList_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // (JType COMMA?)*
  private static boolean exceptionList_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!exceptionList_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "exceptionList_1", c)) break;
    }
    return true;
  }

  // JType COMMA?
  private static boolean exceptionList_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = JType(b, l + 1);
    r = r && exceptionList_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // COMMA?
  private static boolean exceptionList_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "exceptionList_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // "goto" NUMBER
  public static boolean gotoInst(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "gotoInst")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, GOTO_INST, "<goto inst>");
    r = consumeToken(b, "goto");
    r = r && consumeToken(b, NUMBER);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  /* ********************************************************** */
  // "if" LBRACKET LEVEL ("<="|">="|"<"|">"|"=="|"!=") (NUMBER|LEVEL|"null") RBRACKET gotoInst
  public static boolean ifInst(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ifInst")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, IF_INST, "<if inst>");
    r = consumeToken(b, "if");
    r = r && consumeTokens(b, 0, LBRACKET, LEVEL);
    r = r && ifInst_3(b, l + 1);
    r = r && ifInst_4(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    r = r && gotoInst(b, l + 1);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // "<="|">="|"<"|">"|"=="|"!="
  private static boolean ifInst_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ifInst_3")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "<=");
    if (!r) r = consumeToken(b, ">=");
    if (!r) r = consumeToken(b, "<");
    if (!r) r = consumeToken(b, ">");
    if (!r) r = consumeToken(b, "==");
    if (!r) r = consumeToken(b, "!=");
    exit_section_(b, m, null, r);
    return r;
  }

  // NUMBER|LEVEL|"null"
  private static boolean ifInst_4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "ifInst_4")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    if (!r) r = consumeToken(b, LEVEL);
    if (!r) r = consumeToken(b, "null");
    exit_section_(b, m, null, r);
    return r;
  }

  /* ********************************************************** */
  // Annotation* ClassHead LBRACKET AttributesArea? FieldArea? MethodArea? RBRACKET
  static boolean item_(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item_")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = item__0(b, l + 1);
    r = r && ClassHead(b, l + 1);
    r = r && consumeToken(b, LBRACKET);
    r = r && item__3(b, l + 1);
    r = r && item__4(b, l + 1);
    r = r && item__5(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation*
  private static boolean item__0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "item__0", c)) break;
    }
    return true;
  }

  // AttributesArea?
  private static boolean item__3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__3")) return false;
    AttributesArea(b, l + 1);
    return true;
  }

  // FieldArea?
  private static boolean item__4(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__4")) return false;
    FieldArea(b, l + 1);
    return true;
  }

  // MethodArea?
  private static boolean item__5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "item__5")) return false;
    MethodArea(b, l + 1);
    return true;
  }

  /* ********************************************************** */
  // item_
  static boolean jbcFile(PsiBuilder b, int l) {
    return item_(b, l + 1);
  }

  /* ********************************************************** */
  // LBRACKET( ("]")* (STRINGVAR | TacTokens) COLON*)*RBRACKET
  public static boolean lambdaParams(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams")) return false;
    if (!nextTokenIs(b, LBRACKET)) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && lambdaParams_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, LAMBDA_PARAMS, r);
    return r;
  }

  // ( ("]")* (STRINGVAR | TacTokens) COLON*)*
  private static boolean lambdaParams_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!lambdaParams_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1", c)) break;
    }
    return true;
  }

  // ("]")* (STRINGVAR | TacTokens) COLON*
  private static boolean lambdaParams_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = lambdaParams_1_0_0(b, l + 1);
    r = r && lambdaParams_1_0_1(b, l + 1);
    r = r && lambdaParams_1_0_2(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // ("]")*
  private static boolean lambdaParams_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!lambdaParams_1_0_0_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1_0_0", c)) break;
    }
    return true;
  }

  // ("]")
  private static boolean lambdaParams_1_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, "]");
    exit_section_(b, m, null, r);
    return r;
  }

  // STRINGVAR | TacTokens
  private static boolean lambdaParams_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_1")) return false;
    boolean r;
    r = consumeToken(b, STRINGVAR);
    if (!r) r = TacTokens(b, l + 1);
    return r;
  }

  // COLON*
  private static boolean lambdaParams_1_0_2(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "lambdaParams_1_0_2")) return false;
    while (true) {
      int c = current_position_(b);
      if (!consumeToken(b, COLON)) break;
      if (!empty_element_parsed_guard_(b, "lambdaParams_1_0_2", c)) break;
    }
    return true;
  }

  /* ********************************************************** */
  // (LBRACKET((Annotation* Type | LEVEL ) COMMA?)*RBRACKET)?
  public static boolean params(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params")) return false;
    Marker m = enter_section_(b, l, _NONE_, PARAMS, "<params>");
    params_0(b, l + 1);
    exit_section_(b, l, m, true, false, null);
    return true;
  }

  // LBRACKET((Annotation* Type | LEVEL ) COMMA?)*RBRACKET
  private static boolean params_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, LBRACKET);
    r = r && params_0_1(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, m, null, r);
    return r;
  }

  // ((Annotation* Type | LEVEL ) COMMA?)*
  private static boolean params_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1")) return false;
    while (true) {
      int c = current_position_(b);
      if (!params_0_1_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "params_0_1", c)) break;
    }
    return true;
  }

  // (Annotation* Type | LEVEL ) COMMA?
  private static boolean params_0_1_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = params_0_1_0_0(b, l + 1);
    r = r && params_0_1_0_1(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation* Type | LEVEL
  private static boolean params_0_1_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = params_0_1_0_0_0(b, l + 1);
    if (!r) r = consumeToken(b, LEVEL);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation* Type
  private static boolean params_0_1_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = params_0_1_0_0_0_0(b, l + 1);
    r = r && Type(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // Annotation*
  private static boolean params_0_1_0_0_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_0_0_0")) return false;
    while (true) {
      int c = current_position_(b);
      if (!Annotation(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "params_0_1_0_0_0_0", c)) break;
    }
    return true;
  }

  // COMMA?
  private static boolean params_0_1_0_1(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "params_0_1_0_1")) return false;
    consumeToken(b, COMMA);
    return true;
  }

  /* ********************************************************** */
  // "switch" LBRACKET LEVEL RBRACKET LBRACKET((NUMBER|"default") COLON gotoInst SEMICOLON?)*
  // RBRACKET
  public static boolean switchInst(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "switchInst")) return false;
    boolean r;
    Marker m = enter_section_(b, l, _NONE_, SWITCH_INST, "<switch inst>");
    r = consumeToken(b, "switch");
    r = r && consumeTokens(b, 0, LBRACKET, LEVEL, RBRACKET, LBRACKET);
    r = r && switchInst_5(b, l + 1);
    r = r && consumeToken(b, RBRACKET);
    exit_section_(b, l, m, r, false, null);
    return r;
  }

  // ((NUMBER|"default") COLON gotoInst SEMICOLON?)*
  private static boolean switchInst_5(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "switchInst_5")) return false;
    while (true) {
      int c = current_position_(b);
      if (!switchInst_5_0(b, l + 1)) break;
      if (!empty_element_parsed_guard_(b, "switchInst_5", c)) break;
    }
    return true;
  }

  // (NUMBER|"default") COLON gotoInst SEMICOLON?
  private static boolean switchInst_5_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "switchInst_5_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = switchInst_5_0_0(b, l + 1);
    r = r && consumeToken(b, COLON);
    r = r && gotoInst(b, l + 1);
    r = r && switchInst_5_0_3(b, l + 1);
    exit_section_(b, m, null, r);
    return r;
  }

  // NUMBER|"default"
  private static boolean switchInst_5_0_0(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "switchInst_5_0_0")) return false;
    boolean r;
    Marker m = enter_section_(b);
    r = consumeToken(b, NUMBER);
    if (!r) r = consumeToken(b, "default");
    exit_section_(b, m, null, r);
    return r;
  }

  // SEMICOLON?
  private static boolean switchInst_5_0_3(PsiBuilder b, int l) {
    if (!recursion_guard_(b, l, "switchInst_5_0_3")) return false;
    consumeToken(b, SEMICOLON);
    return true;
  }
}
